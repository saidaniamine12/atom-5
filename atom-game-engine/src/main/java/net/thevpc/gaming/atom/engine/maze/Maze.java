/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package net.thevpc.gaming.atom.engine.maze;

import net.thevpc.gaming.atom.model.CellDef;
import net.thevpc.gaming.atom.model.Tile;
import net.thevpc.gaming.atom.model.TileDef;

import java.util.*;

/**
 * Utility class for Maze generation
 *
 * @author Taha Ben Salah (taha.bensalah@gmail.com)
 */
public class Maze {

    /**
     * Maze Generation available Algorithms
     */
    public static enum Algo {

        RANDOM_PRIM,
        DEPTH_FIRST
    }

    /**
     * Maze where Tiles are either Tile.NO_WALL or Tile.WALL_BOX. Ways width in the Maze are of one Unit (one Tile).
     *
     *
     * @param cols    columns in the Maze
     * @param rows    rows in the Maze
     * @param algo    algorithm to use
     * @param factory decorator to decorate Tiles generated by the Maze Generator
     * @return Maze Tile matrix
     */
    public static CellDef[][] generateBoxedMaze(int cols, int rows, Algo algo, MazeDecorator factory) {
        boolean[][] bmaze = generateBoxedMaze(cols, rows, algo);
        CellDef[][] imaze = new CellDef[bmaze.length][bmaze[0].length];
        for (int i = 0; i < imaze.length; i++) {
            CellDef[] is = imaze[i];
            for (int j = 0; j < is.length; j++) {
                TileDef tile = new TileDef();
                int type=0;
                boolean obstacle=false;
                tile.setZ(new int[]{0, 0, 0, 0});
                if (bmaze[i][j]) {
                    tile.setWalls(Tile.WALL_BOX);
                    type=1;
                    obstacle=true;
                }
                CellDef cell = new CellDef(type, tile);
                if (factory != null) {
                    factory.decorate(cell,obstacle);
                }
                is[j] = cell;
            }
        }
        return imaze;
    }

    /**
     * Maze where Tiles are either Tile.NO_WALL or Tile.WALL_BOX. Ways width in the Maze are of one Unit (one Tile).
     *
     *
     * @param cols columns in the Maze
     * @param rows rows in the Maze
     * @param algo algorithm to use
     * @return Maze boolean matrix (true if wall)
     */
    public static boolean[][] generateBoxedMaze(int cols, int rows, Algo algo) {
        if (algo == null) {
            algo = Algo.RANDOM_PRIM;
        }
        switch (algo) {
            case RANDOM_PRIM: {
                RandomPrim m = new RandomPrim();
                return m.generate(rows, cols);
            }
            case DEPTH_FIRST: {
                DepthFirst m = new DepthFirst();
                return m.generate(rows, cols);
            }
        }
        return null;
    }

    /**
     * Maze where Tiles are either Tile.NO_WALL or Tile.WALL_BOX. Ways width in the Maze are of one Unit (one Tile).
     *
     *
     * @param cols columns in the Maze
     * @param rows rows in the Maze
     * @param algo algorithm to use
     * @return Maze boolean matrix (true if wall)
     */
    public static int[][] generateBoxedMaze(int cols, int rows, Algo algo,MazeTypeDecorator decorator) {
        boolean[][] wallsMaze=generateBoxedMaze(cols,rows,algo);
        int[][] richMaze=new int[wallsMaze.length][wallsMaze[0].length];
        for (int i = 0; i < richMaze.length; i++) {
            for (int j = 0; j < richMaze[0].length; j++) {
                richMaze[i][j]=decorator.decorate(i,j,wallsMaze[i][j]);
            }
        }
        return richMaze;
    }

    /**
     * Random Prim Algorithm implementation
     */
    private static class RandomPrim {

        List<TT> next = new ArrayList<TT>();
        boolean[][] matrix;

        public RandomPrim() {
        }

        public boolean[][] generate(int rows, int columns) {
            matrix = new boolean[rows][columns];
            for (boolean[] tiles : matrix) {
                for (int i = 0; i < tiles.length; i++) {
                    tiles[i] = true;
                }
            }

            int c0 = (int) (Math.random() * columns);
            int r0 = (int) (Math.random() * rows);
            TT t0 = new TT(r0, c0);

            add(t0);

            while (next.size() > 0) {
                int v = (int) (Math.random() * next.size());
                add(next.remove(v));
            }
            return matrix;
        }

        private void add(TT t0) {
            if (isAddable(t0)) {
                matrix[t0.row][t0.column] = false;
                addNeighbours(t0);
            }
        }

        private void addNeighbours(TT t0) {
            int c = t0.column;
            int r = t0.row;
            if (c > 0) {
                if (matrix[r][c - 1]) {
                    next.add(new TT(r, c - 1));
                }
            }
            if (c < matrix[0].length - 1) {
                if (matrix[r][c + 1]) {
                    next.add(new TT(r, c + 1));
                }
            }
            if (r > 0) {
                if (matrix[r - 1][c]) {
                    next.add(new TT(r - 1, c));
                }
            }
            if (r < matrix.length - 1) {
                if (matrix[r + 1][c]) {
                    next.add(new TT(r + 1, c));
                }
            }
        }

        private boolean isAddable(TT t0) {
            int c = t0.column;
            int r = t0.row;
            if (!matrix[r][c]) {
                return false;
            }
            int count = 0;
            if (c > 0) {
                if (!matrix[r][c - 1]) {
                    count++;
                }
            }
            if (c < matrix[0].length - 1) {
                if (!matrix[r][c + 1]) {
                    count++;
                }
            }
            if (r > 0) {
                if (!matrix[r - 1][c]) {
                    count++;
                }
            }
            if (r < matrix.length - 1) {
                if (!matrix[r + 1][c]) {
                    count++;
                }
            }
            return count <= 1;
        }
    }

    /**
     * Depth First Algorithm implementation
     */
    private static class DepthFirst {

        boolean[][] matrix;
        HashSet<Integer> visited = new HashSet<Integer>();
        Stack<TT> next = new Stack<TT>();

        public DepthFirst() {
        }

        public boolean[][] generate(int rows, int columns) {
            matrix = new boolean[rows][columns];
            for (boolean[] tiles : matrix) {
                for (int i = 0; i < tiles.length; i++) {
                    tiles[i] = true;

                }
            }
            int c0 = (int) (Math.random() * columns);
            int r0 = (int) (Math.random() * rows);
            TT t0 = new TT(r0, c0);


            next.push(t0);
            while (!next.empty()) {
                TT t = next.pop();
                add(t);
            }
            return matrix;
        }

        private void add(TT t0) {
            if (isAddable(t0)) {
                matrix[t0.row][t0.column] = false;
                addNeighbours(t0);
            }
        }

        private boolean isAddable(TT t0) {
            int c = t0.column;
            int r = t0.row;
            if (!matrix[r][c]) {
                return false;
            }
            int count = 0;
            if (c > 0) {
                if (!matrix[r][c - 1]) {
                    count++;
                }
            }
            if (c < matrix[0].length - 1) {
                if (!matrix[r][c + 1]) {
                    count++;
                }
            }
            if (r > 0) {
                if (!matrix[r - 1][c]) {
                    count++;
                }
            }
            if (r < matrix.length - 1) {
                if (!matrix[r + 1][c]) {
                    count++;
                }
            }
            return count <= 1;
        }

        private void addNeighbours(TT t0) {
            int c = t0.column;
            int r = t0.row;
            List<TT> toAdd = new ArrayList<TT>();
            if (c > 0) {
                if (matrix[r][c - 1]) {
                    toAdd.add(new TT(r, c - 1));
                }
            }
            if (c < matrix[0].length - 1) {
                if (matrix[r][c + 1]) {
                    toAdd.add(new TT(r, c + 1));
                }
            }
            if (r > 0) {
                if (matrix[r - 1][c]) {
                    toAdd.add(new TT(r - 1, c));
                }
            }
            if (r < matrix.length - 1) {
                if (matrix[r + 1][c]) {
                    toAdd.add(new TT(r + 1, c));
                }
            }
            Collections.shuffle(toAdd);
            for (TT tile : toAdd) {
                next.push(tile);
            }
        }
    }

    static class TT {

        int row;
        int column;

        public TT(int row, int column) {
            this.row = row;
            this.column = column;
        }
    }
}
